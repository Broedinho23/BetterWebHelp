<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="topic"/>
<meta name="DC.Title" content="Specialization"/>
<meta name="abstract" content="The specialization feature of DITA allows for the creation of new element types and attributes that are explicitly and formally derived from existing types. The resulting specialization allows for the blind interchange of all conforming DITA content and a minimum level of common processing for all DITA content. It also allows specialization-aware processors to add specialization-specific processing to existing base processing."/>
<meta name="description" content="The specialization feature of DITA allows for the creation of new element types and attributes that are explicitly and formally derived from existing types. The resulting specialization allows for the blind interchange of all conforming DITA content and a minimum level of common processing for all DITA content. It also allows specialization-aware processors to add specialization-specific processing to existing base processing."/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/configuration-specialization-and-constraints.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/createCustomDocType.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/createConstraintsDomainSpec.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/vocabularymodules.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/specvalid.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/classatt.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/domainsatt.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/generalize.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/attributegeneralize.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/foreigncontentspec.html"/>
<meta name="DC.Relation" scheme="URI" content="../archSpec/specialization_module_requirements.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="specialize"/>
<meta name="DC.Language" content="en-us"/>
<title>Specialization</title>
</head>
<body id="specialize">


  
  <h1 class="title topictitle1">Specialization</h1>

  
  <div class="body"><p class="shortdesc">
    <span class="ph" id="shortdesc">The specialization feature of DITA allows for the creation of new element
      types and attributes that are explicitly and formally derived from existing types. The
      resulting specialization allows for the blind interchange of all conforming DITA content and a
      minimum level of common processing for all DITA content. It also allows specialization-aware
      processors to add specialization-specific processing to existing base processing.
    </span></p>

    <div class="section"><h2 class="title sectiontitle">Specializations are explicitly declared in documents</h2>
      
      <p class="p">The specialization feature of DITA defines both a specialization hierarchy declaration
        syntax used in document instances and a set of document type implementation requirements.
        The specialization declarations allow processors to determine what set of specializations
        and associated local constraints a given DITA document uses. The specialization declarations
        for individual elements and attributes allow processors to determine what the type
        hierarchies of those elements and attributes are, from which processors can determine the
        most appropriate (or available) processing to apply. </p>

    </div>

    <div class="section"><h2 class="title sectiontitle">Specialization enables controlled extension</h2>
      
      <p class="p">Specialization allows you to define new kinds of information (new structural types or new
        domains of information), while reusing as much of existing design and code as possible, and
        minimizing or eliminating the costs of interchange, migration, and maintenance. </p>

      <p class="p">In traditional XML applications, all semantics for a given element instance are bound to
        the element type, such as &lt;para&gt; for a paragraph or &lt;title&gt; for a title. The XML
        specification provides no built-in mechanism for relating two element types to say "element
        type B is a subtype of element type A". However, in most documentation-focused XML
        applications there is often a clear hierarchy of types. For example, in a technical manual,
        there might be generic sections and more specialized sections, e.g. "Troubleshooting" or
        "Assembly Procedures". The presentation of the generic and specialized sections might be
        identical, but the more specialized sections might have more restrictive constraints or
        include additional element types relevant only to those section types. While these
        relationships might be understood by authors and system implementors, the XML standard
        provides no direct way to express the relationship, to say explicitly "A Troubleshooting
        section is a generic section and must conform to all requirements of generic sections".
        Having created the element type &lt;section&gt; and implemented presentation processing for it
        and then having later created the element type &lt;troubleshooting&gt;, there is no obvious
        mechanism for having all &lt;troubleshooting&gt; elements <em class="ph i">automatically</em> get the
        processing associated with &lt;section&gt; elements.
        To
        get that behavior someone has to
        explicitly
        update all processors involved to apply &lt;section&gt; processing to &lt;troubleshooting&gt;.</p>

      <p class="p">The DITA specialization feature provides a standard mechanism for saying explicitly, using
        normal XML syntax, "A Troubleshooting section is a generic section and must conform to all
        requirements of generic sections" and, having said that, makes it possible for generic
        section processing to be applied to troubleshooting sections <em class="ph i">with no further
        effort</em>.</p>

    </div>

    <div class="section"><h2 class="title sectiontitle">When to use or not use specialization</h2>
      
      <p class="p">Specialization is used when new structural types or new domains are needed. DITA
        specialization can be used when you want to make changes to your design for the sake of
        increased consistency or descriptiveness or have specific needs for output that cannot be
        addressed using the current data model. Specialization is not normally used for simply
        creating different output
        types,
        as DITA documents may be transformed to different outputs.</p>

      <p class="p">Do not use specialization to simply eliminate unneeded or unwanted element types from
        specific content models. The content models for element types defined in vocabulary modules
        can be configured using separately-defined constraint modules without the need to create new
        specializations. See <a xmlns:functx="http://www.functx.com" class="- topic/xref  ajaxLink" href="archSpec/createConstraintsDomainSpec.html" title="Constraint modules define additional constraints for corresponding vocabulary modules in order to restrict content models or attribute lists for specific element types, remove extension elements from an integrated domain module, or replace base element types with domain-provided extension element types. Constraint modules do not and cannot change element semantics, only the details of how element types can be used in the context of a specific concrete document type. Because constraints can make optional elements required, documents that use the same vocabulary modules may still have incompatible constraints. Thus the use of constraints can affect the ability for content from one topic or map to be used directly in another topic or map.">Constraints</a>.</p>

      <p class="p">Use specialization when you are dealing with new semantics (new, meaningful categories of
        information, either in the form of new structural types or new domains). The new semantics
        can be encoded as part of a specialization hierarchy, that allows them to be processed by
        existing specialization-aware transforms or transformed back to more general equivalents
        ("generalization") for processing by transforms that only understand the unspecialized base
        types. Use constraints to configure content models and attribute lists without changing
        semantics.</p>

    </div>

    <div class="section"><h2 class="title sectiontitle">Types of specialization hierarchy</h2>
      
      <p class="p">There are two kinds of specialization hierarchy: one for structural types (with topic or
        map at the root) and one for domains (with elements in topic or map at their root, or the
        @props or @base attributes). Structural types define topic or map structures, such as
        concept or task or reference, which often apply across subject areas (for example, a user
        interface task and a programming task may both consist of a series of steps). Domains define
        markup for a particular information domain or subject area, such as programming, or
        hardware. Each type of vocabulary module represents an “is a” hierarchy, in object-oriented
        terms, with each structural type or domain being a subclass of its parent. For example, a
        specialization of task is still a task and a specialization of the user interface domain is
        still part of the user interface domain. A given domain can be used with any map or topic
        type, as appropriate for the domain. In addition, specific structural types <dfn class="term">may</dfn>
        require the use of specific domains.</p>

    </div>

    <div class="section"><h2 class="title sectiontitle">Specialization of attributes</h2>
      
      <p class="p">With structural specializations you can limit the allowed values of attributes defined on the base types of specialized types. You can also define new attributes through domain specializations based off of the @props attribute (for conditional processing) or the @base attribute (for other simple token attributes).</p>

      <div class="note note"><span class="notetitle">non-normative:</span> As a general practice, structural specializations should not limit the values of the built-in selection attributes. Use constraint modules to define specific value lists for built-in selection attributes.</div>

      <p class="p">Attribute specialization allows you to define new conditional processing attributes that can be used for filtering and flagging (specializations of @props) or new attributes with no existing equivalent that can be managed and generalized in the same way as conditional processing attributes (specializations of @base). </p>

      <div class="p">New attributes need to be specialized from either @props or @base:<ul class="ul" id="specialize__ul_30446824-c5c6-4d26-813d-0ce71667c3e8">
        <li class="li">Attributes specialized from @props are recognized as conditional processing attributes</li>

        <li class="li">Attributes specialized from @base have no existing behavior associated with them</li>

        <li class="li">Values in specialized attributes should be preserved during generalization and respecialization as for @props</li>

        <li class="li">While generalized, the attribute values should still be understandable by both general and specialized behaviors, and be treated as equivalent to their specialized form. For example, conditional filtering should work the same way on specialized attributes and on generalized attributes.</li>

        </ul>
</div>

    </div>

  </div>

<div xmlns:functx="http://www.functx.com" class="related-links">
<ol class="olchildlinks">
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/vocabularymodules.html">Vocabulary modules</a><br/>
Vocabulary modules are atomic units of XML vocabulary definition (element types and     attributes). A given DITA element type or attribute is declared in exactly one vocabulary     module.</li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/specvalid.html">Requirements for specialized element types and attributes</a><br/>
When you specialize one element from another, or a new attribute from @props or @base,     the new element or attribute <dfn class="term">must</dfn> obey certain rules in order to be a conforming     specialization.</li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/classatt.html">Element type specialization hierarchy declaration (the @class attribute)</a><br/>
Each DITA element declares its specialization hierarchy as the value of the @class     attribute. The @class attribute usually provides a mapping from the element's current name to     its more general equivalents, but it can also provide a mapping from the current name to more     general and more specialized equivalents. All specialization-aware processing can be defined in     terms of @class attribute values without reference to a given element's tagname.</li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/domainsatt.html">Domain usage declaration (the @domains attribute)</a><br/>
Structural types <dfn class="term">must</dfn> declare the domain vocabulary modules and constraint modules they use. This is done with the @domains attribute, whose value is a sequence of parenthesized module ancestry specifications. The @domains attribute is declared on the root element for each topic or map type. Structural modules <dfn class="term">should</dfn> declare their structural ancestry.</li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/generalize.html">Generalization</a><br/>
Specialized content can be generalized to any ancestor type. The generalization process     can preserve information about the former level of specialization to allow round-tripping     between specialized and unspecialized forms of the same content.</li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/attributegeneralize.html">Attribute generalization</a><br/>
There is a particular syntax to generalize attributes that have been specialized from     the @props or @base attribute. Specialization-aware processors <span class="keyword">should</span> be able     to recognize and process both the specialized and generalized forms of an attribute as being     equivalent in their values.</li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/foreigncontentspec.html">Specializing foreign or unknown content</a><br/>
Specializing the &lt;foreign&gt; or &lt;unknown&gt; element is an open extension to     DITA for the purpose of incorporating standard vocabularies for non-textual content, such as     MathML and SVG, as in-line objects. <span class="ph">These elements <span class="keyword">should not</span>       be used to include textual content or metadata in DITA documents except where such content       acts as an example or display, rather than as the primary content of a topic.</span></li>
<li class="link olchildlink"><a class="- topic/link  ajaxLink" href="archSpec/../archSpec/specialization_module_requirements.html">Specialization module coding requirements</a><br/>
The base DITA element and attribute types may be extended through the creation of new vocabulary modules that define specializations of more-general types.</li>
</ol>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="- topic/link  ajaxLink" href="archSpec/../archSpec/configuration-specialization-and-constraints.html" title="The extension facilities of DITA allow existing vocabulary and constraint modules to be combined to create specific DITA document types. Additionally, vocabulary modules can be extended to create more-specialized markup to meet new requirements not satisfied by existing markup.">Configuration, specialization, and constraints</a></div>
<div class="previouslink"><strong>Previous topic:</strong> <a class="- topic/link  ajaxLink" href="archSpec/../archSpec/createCustomDocType.html" title="A given DITA map or topic document is governed by a DITA document type that defines the set of structural modules (topic or map types), domain modules, and constraints modules that the map or topic can use.">Configuration (Document type shells)</a></div>
<div class="nextlink"><strong>Next topic:</strong> <a class="- topic/link  ajaxLink" href="archSpec/../archSpec/createConstraintsDomainSpec.html" title="Constraint modules define additional constraints for corresponding vocabulary modules in order to restrict content models or attribute lists for specific element types, remove extension elements from an integrated domain module, or replace base element types with domain-provided extension element types. Constraint modules do not and cannot change element semantics, only the details of how element types can be used in the context of a specific concrete document type. Because constraints can make optional elements required, documents that use the same vocabulary modules may still have incompatible constraints. Thus the use of constraints can affect the ability for content from one topic or map to be used directly in another topic or map.">Constraints</a></div>
</div>
</div>

</body>
</html>